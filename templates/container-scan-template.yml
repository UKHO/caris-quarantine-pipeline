parameters:
  - name: sourceAzureSubscription
    type: string
  - name: sourceRegistryServiceConnection
    type: string
  - name: destinationRegistryServiceConnection
    type: string
  - name: preRegistryServiceConnection
    type: string
  - name: destinationRegistry
    type: string
  - name: preRegistry
    type: string
  - name: snykServiceConnection
    type: string
  - name: snykOrganization
    type: string
  - name: teamsWebhookEndpoint
    type: string
  - name: sourceRepository
    type: string
  - name: sourceTag
    type: string
  - name: sourceHost
    type: string

stages:
- stage: ScanContainer
  displayName: 'Scan Container'
  jobs:
  - job: ContainerScan
    displayName: 'Scan Pushed Image'
    pool:
      name: Tiberius
      demands:
      - ENVIRONMENT -equals BUS
    steps:
    - task: AzureCLI@2
      displayName: 'Check if Helm Chart'
      inputs:
        azureSubscription: '${{ parameters.sourceAzureSubscription }}'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Check if tag is provided (Helm charts don't have tags)
          $tag = "${{ parameters.sourceTag }}"
          if ([string]::IsNullOrWhiteSpace($tag)) {
            Write-Host "##[warning]No tag provided - likely a Helm chart, skipping container scan pipeline"
            Write-Host "##vso[task.setvariable variable=isHelmChart;isOutput=true]true"
            Write-Host "##vso[task.complete result=Skipped;]No tag provided - use helm pipeline instead"
            exit 0
          }
          
          # Get manifest to check media type
          $registryName = "${{ parameters.sourceHost }}".Split('.')[0]
          $manifest = az acr manifest show --name ${{ parameters.sourceRepository }}:$tag --registry $registryName --output json | ConvertFrom-Json
          
          # Check if this is a Helm chart by looking at config media type
          $isHelmChart = $manifest.config.mediaType -eq "application/vnd.cncf.helm.config.v1+json"
          
          if ($isHelmChart) {
            Write-Host "##[warning]Detected Helm chart - skipping container scan pipeline"
            Write-Host "##vso[task.setvariable variable=isHelmChart;isOutput=true]true"
            Write-Host "##vso[task.complete result=Skipped;]Helm chart detected - use helm pipeline instead"
            exit 0
          } else {
            Write-Host "##vso[task.setvariable variable=isHelmChart;isOutput=true]false"
          }
      name: detectType

    - task: Docker@2
      displayName: 'Login to Source Registry'
      condition: eq(variables['detectType.isHelmChart'], 'false')
      inputs:
        containerRegistry: '${{ parameters.sourceRegistryServiceConnection }}'
        command: 'login'

    - task: PowerShell@2
      displayName: 'Pull Published Image'
      condition: eq(variables['detectType.isHelmChart'], 'false')
      inputs:
        targetType: 'inline'
        script: |
          docker pull ${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}

    - task: UkhoSnykScanTask@0
      displayName: 'Snyk container scan'
      condition: eq(variables['detectType.isHelmChart'], 'false')
      inputs:
        failOnIssues: true
        organization: '${{ parameters.snykOrganization }}'
        serviceConnectionEndpoint: '${{ parameters.snykServiceConnection }}'
        testType: container
        monitorWhen: always
        severityThreshold: high
        dockerImageName: '${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}'

- stage: PushToPreACR
  displayName: 'Push scanned image to Pre ACR'
  dependsOn: ScanContainer
  condition: and(succeeded(), eq(dependencies.ScanContainer.outputs['ContainerScan.detectType.isHelmChart'], 'false'))
  jobs:
  - job: PushToPre
    displayName: 'Push to Pre ACR'
    pool:
      name: Tiberius
      demands:
      - ENVIRONMENT -equals ENG
    variables:
      scannedImageTag: '${{ parameters.sourceTag }}-snyk-scanned'
      preImageRepository: 'scanned/${{ parameters.sourceRepository }}'
      fullPreImageName: '${{ parameters.preRegistry }}/scanned/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}-snyk-scanned'
    steps:
    - task: Docker@2
      displayName: 'Login to Source Registry'
      inputs:
        containerRegistry: '${{ parameters.sourceRegistryServiceConnection }}'
        command: 'login'

    - task: PowerShell@2
      displayName: 'Pull Published Image'
      inputs:
        targetType: 'inline'
        script: |
          docker pull ${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}

    - task: Docker@2
      displayName: 'Login to Pre Registry'
      inputs:
        containerRegistry: '${{ parameters.preRegistryServiceConnection }}'
        command: 'login'

    - task: Docker@2
      displayName: 'Tag Image for Pre'
      inputs:
        command: 'tag'
        arguments: '${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }} $(fullPreImageName)'

    - task: Docker@2
      displayName: 'Push Scanned Image to Pre Registry'
      inputs:
        containerRegistry: '${{ parameters.preRegistryServiceConnection }}'
        repository: '$(preImageRepository)'
        command: 'push'
        tags: '$(scannedImageTag)'

    - script: |
        echo "✅ Container pushed to Pre ACR successfully!"
        echo "Source image: ${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}"
        echo "Pre image: $(fullPreImageName)"
      displayName: 'Pre Push Summary'

- stage: PushToPrivateRepo
  displayName: 'Push passed image to Private ACR'
  dependsOn: PushToPreACR
  condition: and(succeeded(), eq(dependencies.ScanContainer.outputs['ContainerScan.detectType.isHelmChart'], 'false'))
  jobs:
  - job: PullTagAndPush
    displayName: 'Pull, Tag and Push the image to the Private ACR'
    pool:
      name: Tiberius
      demands:
      - ENVIRONMENT -equals BUS
    variables:
      scannedImageTag: '${{ parameters.sourceTag }}-snyk-scanned'
      destinationImageRepository: 'scanned/${{ parameters.sourceRepository }}'
      fullDestinationImageName: '${{ parameters.destinationRegistry }}/scanned/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}-snyk-scanned'
    steps:
    - task: Docker@2
      displayName: 'Login to Source Registry'
      inputs:
        containerRegistry: '${{ parameters.sourceRegistryServiceConnection }}'
        command: 'login'

    - task: PowerShell@2
      displayName: 'Pull Published Image'
      inputs:
        targetType: 'inline'
        script: |
          docker pull ${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}

    - task: Docker@2
      displayName: 'Login to Destination Registry'
      inputs:
        containerRegistry: '${{ parameters.destinationRegistryServiceConnection }}'
        command: 'login'

    - task: Docker@2
      displayName: 'Tag Image as Snyk Scanned'
      inputs:
        command: 'tag'
        arguments: '${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }} $(fullDestinationImageName)'

    - task: Docker@2
      displayName: 'Push Scanned Image to Destination Registry'
      inputs:
        containerRegistry: '${{ parameters.destinationRegistryServiceConnection }}'
        repository: '$(destinationImageRepository)'
        command: 'push'
        tags: '$(scannedImageTag)'

    - script: |
        echo "✅ Container scanning and push completed successfully!"
        echo "Source image: ${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}"
        echo "Destination image: $(fullDestinationImageName)"
      displayName: 'Pipeline Summary'

- stage: AlertOnSuccess
  displayName: 'Alert that scan completed successfully'
  dependsOn: [PushToPreACR, PushToPrivateRepo]
  condition: and(succeeded(), eq(dependencies.ScanContainer.outputs['ContainerScan.detectType.isHelmChart'], 'false'))
  jobs:
  - job: SendSuccessTeamsMessage
    displayName: 'Send Success Alert to Teams Channel'
    pool: Mare Nectaris
    variables:
      scannedImageTag: '${{ parameters.sourceTag }}-snyk-scanned'
      fullDestinationImageName: '${{ parameters.destinationRegistry }}/scanned/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}-snyk-scanned'
      fullPreImageName: '${{ parameters.preRegistry }}/scanned/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}-snyk-scanned'
    steps:
    - task: PowerShell@2
      displayName: 'Send Teams Alert'
      inputs:
        targetType: 'inline'
        script: |
          $body = @{
            title = "Container Scan Completed Successfully"
            message = "Container scanning passed and image has been pushed to live and pre private registries."
            status = "success"
            sourceHost = "${{ parameters.sourceHost }}"
            sourceRepository = "${{ parameters.sourceRepository }}"
            sourceTag = "${{ parameters.sourceTag }}"
            destinationImage = "$(fullDestinationImageName)"
            preImage = "$(fullPreImageName)"
            pipelineUrl = "$(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
          } | ConvertTo-Json
          
          Invoke-RestMethod -Uri "${{ parameters.teamsWebhookEndpoint }}" -Method Post -Body $body -ContentType 'application/json'

- stage: AlertOnFail
  displayName: 'Alert that vulnerable image present'
  dependsOn: ScanContainer
  condition: and(failed(), eq(dependencies.ScanContainer.outputs['ContainerScan.detectType.isHelmChart'], 'false'))
  jobs:
  - job: PushPreVulnerableImage
    displayName: 'Push Vulnerable Image to Pre vulnerable namespace'
    pool:
      name: Tiberius
      demands:
      - ENVIRONMENT -equals ENG
    variables:
      vulnerableImageTag: '${{ parameters.sourceTag }}-vulnerable'
      preVulnerableImageRepository: 'vulnerable/${{ parameters.sourceRepository }}'
      fullPreVulnerableImageName: '${{ parameters.preRegistry }}/vulnerable/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}-vulnerable'
    steps:
    - task: Docker@2
      displayName: 'Login to Source Registry'
      inputs:
        containerRegistry: '${{ parameters.sourceRegistryServiceConnection }}'
        command: 'login'

    - task: PowerShell@2
      displayName: 'Pull Published Image'
      inputs:
        targetType: 'inline'
        script: |
          docker pull ${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}

    - task: Docker@2
      displayName: 'Login to Pre Registry'
      inputs:
        containerRegistry: '${{ parameters.preRegistryServiceConnection }}'
        command: 'login'

    - task: Docker@2
      displayName: 'Tag Image as Vulnerable for Pre'
      inputs:
        command: 'tag'
        arguments: '${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }} $(fullPreVulnerableImageName)'

    - task: Docker@2
      displayName: 'Push Vulnerable Image to Pre Registry'
      inputs:
        containerRegistry: '${{ parameters.preRegistryServiceConnection }}'
        repository: '$(preVulnerableImageRepository)'
        command: 'push'
        tags: '$(vulnerableImageTag)'

  - job: PushVulnerableImage
    displayName: 'Push Vulnerable Image to vulnerable namespace'
    dependsOn: PushPreVulnerableImage
    pool:
      name: Tiberius
      demands:
      - ENVIRONMENT -equals BUS
    variables:
      vulnerableImageTag: '${{ parameters.sourceTag }}-vulnerable'
      vulnerableImageRepository: 'vulnerable/${{ parameters.sourceRepository }}'
      fullVulnerableImageName: '${{ parameters.destinationRegistry }}/vulnerable/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}-vulnerable'
    steps:
    - task: Docker@2
      displayName: 'Login to Source Registry'
      inputs:
        containerRegistry: '${{ parameters.sourceRegistryServiceConnection }}'
        command: 'login'

    - task: PowerShell@2
      displayName: 'Pull Published Image'
      inputs:
        targetType: 'inline'
        script: |
          docker pull ${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}

    - task: Docker@2
      displayName: 'Login to Destination Registry'
      inputs:
        containerRegistry: '${{ parameters.destinationRegistryServiceConnection }}'
        command: 'login'

    - task: Docker@2
      displayName: 'Tag Image as Vulnerable'
      inputs:
        command: 'tag'
        arguments: '${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }} $(fullVulnerableImageName)'

    - task: Docker@2
      displayName: 'Push Vulnerable Image'
      inputs:
        containerRegistry: '${{ parameters.destinationRegistryServiceConnection }}'
        repository: '$(vulnerableImageRepository)'
        command: 'push'
        tags: '$(vulnerableImageTag)'

  - job: SendFailureTeamsMessage
    displayName: 'Send Failure Alert to Teams Channel'
    dependsOn: [PushPreVulnerableImage, PushVulnerableImage]
    condition: always()
    pool: Mare Nectaris
    variables:
      vulnerableImageTag: '${{ parameters.sourceTag }}-vulnerable'
      fullVulnerableImageName: '${{ parameters.destinationRegistry }}/vulnerable/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}-vulnerable'
      fullPreVulnerableImageName: '${{ parameters.preRegistry }}/vulnerable/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}-vulnerable'
    steps:
    - task: PowerShell@2
      displayName: 'Send Teams Alert'
      inputs:
        targetType: 'inline'
        script: |
          $body = @{
            title = "Container Scan Failed"
            message = "Container scanning failed due to vulnerabilities detected in image: ${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}. Vulnerable images pushed to live and pre registries."
            status = "failure"
            sourceHost = "${{ parameters.sourceHost }}"
            sourceRepository = "${{ parameters.sourceRepository }}"
            sourceTag = "${{ parameters.sourceTag }}"
            vulnerableImage = "$(fullVulnerableImageName)"
            preVulnerableImage = "$(fullPreVulnerableImageName)"
            pipelineUrl = "$(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
          } | ConvertTo-Json
          
          Invoke-RestMethod -Uri "${{ parameters.teamsWebhookEndpoint }}" -Method Post -Body $body -ContentType 'application/json'

    - script: |
        echo "❌ Container scanning failed!"
        echo "Source image: ${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}"
      displayName: 'Pipeline Summary'
