parameters:
  - name: sourceAzureSubscription
    type: string
  - name: preAzureSubscription
    type: string
  - name: liveAzureSubscription
    type: string
  - name: sourceRegistryServiceConnection
    type: string
  - name: destinationRegistryServiceConnection
    type: string
  - name: preRegistryServiceConnection
    type: string
  - name: destinationRegistry
    type: string
  - name: preRegistry
    type: string
  - name: snykServiceConnection
    type: string
  - name: snykOrganization
    type: string
  - name: teamsWebhookEndpoint
    type: string
  - name: sourceRepository
    type: string
  - name: sourceTag
    type: string
  - name: sourceHost
    type: string
  - name: enableHelmStages
    type: boolean
    default: true

stages:
- stage: ScanContainer
  displayName: 'Scan Container'
  jobs:
  - job: ContainerScan
    displayName: 'Scan Pushed Image'
    pool:
      name: Tiberius
      demands:
      - ENVIRONMENT -equals BUS
    steps:
    - task: AzureCLI@2
      displayName: 'Detect Artifact Type (Container vs Helm Chart)'
      inputs:
        azureSubscription: '${{ parameters.sourceAzureSubscription }}'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Determine manifest reference (containers have tags, Helm charts typically do not)
          $tag = "${{ parameters.sourceTag }}"
          $registryName = "${{ parameters.sourceHost }}".Split('.')[0]
          if ([string]::IsNullOrWhiteSpace($tag)) {
            $manifestName = "${{ parameters.sourceRepository }}"
          } else {
            $manifestName = "${{ parameters.sourceRepository }}:$tag"
          }

          Write-Host "Inspecting manifest: $manifestName"

          $manifest = $null
          try {
            $manifestJson = az acr manifest show --name $manifestName --registry $registryName --output json 2>$null
            if (-not [string]::IsNullOrWhiteSpace($manifestJson)) {
              $manifest = $manifestJson | ConvertFrom-Json
            }
          } catch {
            Write-Host "##[warning]Unable to inspect manifest '$manifestName' in registry '$registryName'. Defaulting to container path."
          }

          $helmMediaType = "application/vnd.cncf.helm.config.v1+json"
          $isHelmChart = $false
          if ($manifest -and $manifest.config -and $manifest.config.mediaType -eq $helmMediaType) {
            $isHelmChart = $true
          }

          if ($isHelmChart) {
            Write-Host "✓ Detected Helm chart (config.mediaType: $($manifest.config.mediaType))"
            Write-Host "  → Will use Snyk IaC scanning for Helm chart"
            Write-Host "##vso[task.setvariable variable=isHelmChart;isOutput=true]true"
          } else {
            if ($manifest -and $manifest.config) {
              Write-Host "✓ Detected container image (config.mediaType: $($manifest.config.mediaType))"
            } else {
              Write-Host "✓ Treating artifact as container image because manifest inspection failed."
            }
            Write-Host "  → Will use Snyk container scanning"
            Write-Host "##vso[task.setvariable variable=isHelmChart;isOutput=true]false"
          }
      name: detectType

    - task: Docker@2
      displayName: 'Login to Source Registry'
      condition: eq(variables['detectType.isHelmChart'], 'false')
      inputs:
        containerRegistry: '${{ parameters.sourceRegistryServiceConnection }}'
        command: 'login'

    - task: PowerShell@2
      displayName: 'Pull Published Image'
      condition: eq(variables['detectType.isHelmChart'], 'false')
      inputs:
        targetType: 'inline'
        script: |
          docker pull ${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}

    - task: UkhoSnykScanTask@0
      displayName: 'Snyk container scan'
      condition: eq(variables['detectType.isHelmChart'], 'false')
      inputs:
        failOnIssues: true
        organization: '${{ parameters.snykOrganization }}'
        serviceConnectionEndpoint: '${{ parameters.snykServiceConnection }}'
        testType: container
        monitorWhen: always
        severityThreshold: high
        dockerImageName: '${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}'

- stage: PushToPreACR
  displayName: 'Push scanned image to Pre ACR'
  dependsOn: ScanContainer
  condition: and(succeeded(), eq(dependencies.ScanContainer.outputs['ContainerScan.detectType.isHelmChart'], 'false'))
  jobs:
  - job: PushToPre
    displayName: 'Push to Pre ACR'
    pool:
      name: Tiberius
      demands:
      - ENVIRONMENT -equals ENG
    variables:
      scannedImageTag: '${{ parameters.sourceTag }}-snyk-scanned'
      preImageRepository: 'scanned/${{ parameters.sourceRepository }}'
      fullPreImageName: '${{ parameters.preRegistry }}/scanned/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}-snyk-scanned'
    steps:
    - task: Docker@2
      displayName: 'Login to Source Registry'
      inputs:
        containerRegistry: '${{ parameters.sourceRegistryServiceConnection }}'
        command: 'login'

    - task: PowerShell@2
      displayName: 'Pull Published Image'
      inputs:
        targetType: 'inline'
        script: |
          docker pull ${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}

    - task: Docker@2
      displayName: 'Login to Pre Registry'
      inputs:
        containerRegistry: '${{ parameters.preRegistryServiceConnection }}'
        command: 'login'

    - task: Docker@2
      displayName: 'Tag Image for Pre'
      inputs:
        command: 'tag'
        arguments: '${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }} $(fullPreImageName)'

    - task: Docker@2
      displayName: 'Push Scanned Image to Pre Registry'
      inputs:
        containerRegistry: '${{ parameters.preRegistryServiceConnection }}'
        repository: '$(preImageRepository)'
        command: 'push'
        tags: '$(scannedImageTag)'

- stage: PushToPrivateRepo
  displayName: 'Push passed image to Private ACR'
  dependsOn: PushToPreACR
  condition: and(succeeded(), eq(dependencies.ScanContainer.outputs['ContainerScan.detectType.isHelmChart'], 'false'))
  jobs:
  - job: PullTagAndPush
    displayName: 'Pull, Tag and Push the image to the Private ACR'
    pool:
      name: Tiberius
      demands:
      - ENVIRONMENT -equals BUS
    variables:
      scannedImageTag: '${{ parameters.sourceTag }}-snyk-scanned'
      destinationImageRepository: 'scanned/${{ parameters.sourceRepository }}'
      fullDestinationImageName: '${{ parameters.destinationRegistry }}/scanned/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}-snyk-scanned'
    steps:
    - task: Docker@2
      displayName: 'Login to Source Registry'
      inputs:
        containerRegistry: '${{ parameters.sourceRegistryServiceConnection }}'
        command: 'login'

    - task: PowerShell@2
      displayName: 'Pull Published Image'
      inputs:
        targetType: 'inline'
        script: |
          docker pull ${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}

    - task: Docker@2
      displayName: 'Login to Destination Registry'
      inputs:
        containerRegistry: '${{ parameters.destinationRegistryServiceConnection }}'
        command: 'login'

    - task: Docker@2
      displayName: 'Tag Image as Snyk Scanned'
      inputs:
        command: 'tag'
        arguments: '${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }} $(fullDestinationImageName)'

    - task: Docker@2
      displayName: 'Push Scanned Image to Destination Registry'
      inputs:
        containerRegistry: '${{ parameters.destinationRegistryServiceConnection }}'
        repository: '$(destinationImageRepository)'
        command: 'push'
        tags: '$(scannedImageTag)'

- stage: AlertOnSuccess
  displayName: 'Alert that scan completed successfully'
  dependsOn: [PushToPreACR, PushToPrivateRepo]
  condition: and(succeeded(), eq(dependencies.ScanContainer.outputs['ContainerScan.detectType.isHelmChart'], 'false'))
  jobs:
  - job: SendSuccessTeamsMessage
    displayName: 'Send Success Alert to Teams Channel'
    pool: Mare Nectaris
    variables:
      scannedImageTag: '${{ parameters.sourceTag }}-snyk-scanned'
      fullDestinationImageName: '${{ parameters.destinationRegistry }}/scanned/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}-snyk-scanned'
      fullPreImageName: '${{ parameters.preRegistry }}/scanned/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}-snyk-scanned'
    steps:
    - task: PowerShell@2
      displayName: 'Send Teams Alert'
      inputs:
        targetType: 'inline'
        script: |
          $body = @{
            title = "Container Scan Completed Successfully"
            message = "Container scanning passed and image has been pushed to live and pre private registries."
            status = "success"
            sourceHost = "${{ parameters.sourceHost }}"
            sourceRepository = "${{ parameters.sourceRepository }}"
            sourceTag = "${{ parameters.sourceTag }}"
            destinationImage = "$(fullDestinationImageName)"
            preImage = "$(fullPreImageName)"
            pipelineUrl = "$(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
          } | ConvertTo-Json
          
          Invoke-RestMethod -Uri "${{ parameters.teamsWebhookEndpoint }}" -Method Post -Body $body -ContentType 'application/json'

- stage: AlertOnFail
  displayName: 'Alert that vulnerable image present'
  dependsOn: ScanContainer
  condition: and(failed(), eq(dependencies.ScanContainer.outputs['ContainerScan.detectType.isHelmChart'], 'false'))
  jobs:
  - job: PushPreVulnerableImage
    displayName: 'Push Vulnerable Image to Pre ACR'
    pool:
      name: Tiberius
      demands:
      - ENVIRONMENT -equals ENG
    variables:
      vulnerableImageTag: '${{ parameters.sourceTag }}-vulnerable'
      preVulnerableImageRepository: 'vulnerable/${{ parameters.sourceRepository }}'
      fullPreVulnerableImageName: '${{ parameters.preRegistry }}/vulnerable/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}-vulnerable'
    steps:
    - task: Docker@2
      displayName: 'Login to Source Registry'
      inputs:
        containerRegistry: '${{ parameters.sourceRegistryServiceConnection }}'
        command: 'login'

    - task: PowerShell@2
      displayName: 'Pull Published Image'
      inputs:
        targetType: 'inline'
        script: |
          docker pull ${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}

    - task: Docker@2
      displayName: 'Login to Pre Registry'
      inputs:
        containerRegistry: '${{ parameters.preRegistryServiceConnection }}'
        command: 'login'

    - task: Docker@2
      displayName: 'Tag Image as Vulnerable for Pre'
      inputs:
        command: 'tag'
        arguments: '${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }} $(fullPreVulnerableImageName)'

    - task: Docker@2
      displayName: 'Push Vulnerable Image to Pre Registry'
      inputs:
        containerRegistry: '${{ parameters.preRegistryServiceConnection }}'
        repository: '$(preVulnerableImageRepository)'
        command: 'push'
        tags: '$(vulnerableImageTag)'

  - job: PushVulnerableImage
    displayName: 'Push Vulnerable Image to Live ACR'
    dependsOn: PushPreVulnerableImage
    pool:
      name: Tiberius
      demands:
      - ENVIRONMENT -equals BUS
    variables:
      vulnerableImageTag: '${{ parameters.sourceTag }}-vulnerable'
      vulnerableImageRepository: 'vulnerable/${{ parameters.sourceRepository }}'
      fullVulnerableImageName: '${{ parameters.destinationRegistry }}/vulnerable/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}-vulnerable'
    steps:
    - task: Docker@2
      displayName: 'Login to Source Registry'
      inputs:
        containerRegistry: '${{ parameters.sourceRegistryServiceConnection }}'
        command: 'login'

    - task: PowerShell@2
      displayName: 'Pull Published Image'
      inputs:
        targetType: 'inline'
        script: |
          docker pull ${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}

    - task: Docker@2
      displayName: 'Login to Destination Registry'
      inputs:
        containerRegistry: '${{ parameters.destinationRegistryServiceConnection }}'
        command: 'login'

    - task: Docker@2
      displayName: 'Tag Image as Vulnerable'
      inputs:
        command: 'tag'
        arguments: '${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }} $(fullVulnerableImageName)'

    - task: Docker@2
      displayName: 'Push Vulnerable Image'
      inputs:
        containerRegistry: '${{ parameters.destinationRegistryServiceConnection }}'
        repository: '$(vulnerableImageRepository)'
        command: 'push'
        tags: '$(vulnerableImageTag)'

  - job: SendFailureTeamsMessage
    displayName: 'Send Failure Alert to Teams Channel'
    dependsOn: [PushPreVulnerableImage, PushVulnerableImage]
    condition: always()
    pool: Mare Nectaris
    variables:
      vulnerableImageTag: '${{ parameters.sourceTag }}-vulnerable'
      fullVulnerableImageName: '${{ parameters.destinationRegistry }}/vulnerable/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}-vulnerable'
      fullPreVulnerableImageName: '${{ parameters.preRegistry }}/vulnerable/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}-vulnerable'
    steps:
    - task: PowerShell@2
      displayName: 'Send Teams Alert'
      inputs:
        targetType: 'inline'
        script: |
          $body = @{
            title = "Container Scan Failed"
            message = "Container scanning failed due to vulnerabilities detected in image: ${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}:${{ parameters.sourceTag }}. Vulnerable images pushed to live and pre registries."
            status = "failure"
            sourceHost = "${{ parameters.sourceHost }}"
            sourceRepository = "${{ parameters.sourceRepository }}"
            sourceTag = "${{ parameters.sourceTag }}"
            vulnerableImage = "$(fullVulnerableImageName)"
            preVulnerableImage = "$(fullPreVulnerableImageName)"
            pipelineUrl = "$(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
          } | ConvertTo-Json
          
          Invoke-RestMethod -Uri "${{ parameters.teamsWebhookEndpoint }}" -Method Post -Body $body -ContentType 'application/json'

# ============================================
# HELM CHART SCANNING STAGES (run when isHelmChart == 'true')
# ============================================

- stage: ScanHelmChart
  displayName: 'Scan Helm Chart with Snyk IaC'
  dependsOn: ScanContainer
  condition: and(${{ parameters.enableHelmStages }}, in(dependencies.ScanContainer.result, 'Succeeded', 'SucceededWithIssues'), eq(dependencies.ScanContainer.outputs['ContainerScan.detectType.isHelmChart'], 'true'))
  jobs:
  - job: HelmChartScan
    displayName: 'Scan Pushed Helm Chart'
    pool:
      name: Tiberius
      demands:
      - ENVIRONMENT -equals BUS
    steps:
    - task: AzureCLI@2
      displayName: 'Login to ACR and Pull Helm Chart'
      inputs:
        azureSubscription: '${{ parameters.sourceAzureSubscription }}'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Extract registry name from host
          $registryName = "${{ parameters.sourceHost }}" -split '\.' | Select-Object -First 1
          
          # Login to ACR
          az acr login --name $registryName
          
          # Get the chart version from manifest (Helm charts don't have sourceTag in webhook)
          $manifest = az acr manifest show --name ${{ parameters.sourceRepository }} --registry $registryName --output json | ConvertFrom-Json
          $chartVersion = $manifest.config.annotations.'org.opencontainers.image.version'
          
          if ([string]::IsNullOrWhiteSpace($chartVersion)) {
            Write-Host "##[warning]Could not determine chart version from manifest, using sourceTag parameter"
            $chartVersion = "${{ parameters.sourceTag }}"
          }
          
          Write-Host "Helm chart version: $chartVersion"
          Write-Host "##vso[task.setvariable variable=helmChartVersion]$chartVersion"
          
          # Create temp directory for chart
          $chartDir = New-Item -ItemType Directory -Path "$(Agent.TempDirectory)/helm-charts" -Force
          
          # Pull the Helm chart
          $chartReference = "oci://${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}"
          Write-Host "Pulling Helm chart: $chartReference --version $chartVersion"
          helm pull $chartReference --version $chartVersion --destination $chartDir.FullName --untar
          
          # Set variable for extracted chart path
          $extractedChart = Get-ChildItem -Path $chartDir.FullName -Directory | Select-Object -First 1
          Write-Host "##vso[task.setvariable variable=helmChartPath]$($extractedChart.FullName)"
          Write-Host "Helm chart extracted to: $($extractedChart.FullName)"

    - task: UkhoSnykScanTask@0
      displayName: 'Snyk IaC scan for Helm Chart'
      inputs:
        failOnIssues: true
        organization: '${{ parameters.snykOrganization }}'
        serviceConnectionEndpoint: '${{ parameters.snykServiceConnection }}'
        testType: iac
        monitorWhen: always
        severityThreshold: high
        targetFile: '$(helmChartPath)'

- stage: PushHelmToPreACR
  displayName: 'Push scanned Helm chart to Pre ACR'
  dependsOn: ScanHelmChart
  condition: and(${{ parameters.enableHelmStages }}, succeeded())
  jobs:
  - job: PushHelmToPre
    displayName: 'Push Helm Chart to Pre ACR'
    pool:
      name: Tiberius
      demands:
      - ENVIRONMENT -equals ENG
    variables:
      scannedChartTag: '$(helmChartVersion)-snyk-scanned'
      # Helm appends chart name from Chart.yaml, so use parent path only
      preChartRepository: 'scanned/testcharts'
    steps:
    - task: AzureCLI@2
      displayName: 'Pull Helm Chart from Source ACR'
      inputs:
        azureSubscription: '${{ parameters.sourceAzureSubscription }}'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Extract registry name
          $sourceRegistryName = "${{ parameters.sourceHost }}" -split '\.' | Select-Object -First 1
          
          # Login to source ACR
          az acr login --name $sourceRegistryName
          
          # Get the chart version from manifest (same method as scan stage)
          $manifest = az acr manifest show --name ${{ parameters.sourceRepository }} --registry $sourceRegistryName --output json | ConvertFrom-Json
          $chartVersion = $manifest.config.annotations.'org.opencontainers.image.version'
          
          if ([string]::IsNullOrWhiteSpace($chartVersion)) {
            Write-Host "##[warning]Could not determine chart version from manifest, using sourceTag parameter"
            $chartVersion = "${{ parameters.sourceTag }}"
          }
          
          Write-Host "Using chart version: $chartVersion"
          Write-Host "##vso[task.setvariable variable=helmChartVersion]$chartVersion"
          
          # Create temp directory
          $chartDir = New-Item -ItemType Directory -Path "$(Agent.TempDirectory)/helm-charts-push" -Force
          
          # Pull the Helm chart
          $chartReference = "oci://${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}"
          Write-Host "Pulling Helm chart: $chartReference --version $chartVersion"
          helm pull $chartReference --version $chartVersion --destination $chartDir.FullName
          
          # Get the downloaded chart file
          $chartFile = Get-ChildItem -Path $chartDir.FullName -Filter "*.tgz" | Select-Object -First 1
          
          # Extract and modify version
          $extractDir = New-Item -ItemType Directory -Path "$(Agent.TempDirectory)/helm-repackage" -Force
          tar -xzf $chartFile.FullName -C $extractDir.FullName
          
          $chartName = Get-ChildItem -Path $extractDir.FullName -Directory | Select-Object -First 1
          $chartYaml = Get-Content "$($chartName.FullName)/Chart.yaml" -Raw
          $newVersion = "$chartVersion-snyk-scanned"
          $chartYaml = $chartYaml -replace 'version:\s+.*', "version: $newVersion"
          Set-Content "$($chartName.FullName)/Chart.yaml" -Value $chartYaml
          
          # Repackage with new version
          $packageOutput = helm package $chartName.FullName --destination $chartDir.FullName
          Write-Host $packageOutput
          
          # Extract the actual file path from helm package output
          # Output format: "Successfully packaged chart and saved it to: /path/to/chart.tgz"
          if ($packageOutput -match ':\s+(.+\.tgz)$') {
            $repackagedChart = $matches[1]
          } else {
            # Fallback: find the .tgz file
            $repackagedChart = (Get-ChildItem -Path $chartDir.FullName -Filter "*-$newVersion.tgz" | Select-Object -First 1).FullName
          }
          
          Write-Host "Repackaged chart path: $repackagedChart"
          Write-Host "##vso[task.setvariable variable=repackagedChartPath]$repackagedChart"
          Write-Host "##vso[task.setvariable variable=helmChartVersion;isOutput=true]$chartVersion"
          Write-Host "##vso[task.setvariable variable=scannedChartVersion;isOutput=true]$newVersion"
      name: pullChart

    - task: AzureCLI@2
      displayName: 'Push Helm Chart to Pre ACR'
      inputs:
        azureSubscription: '${{ parameters.preAzureSubscription }}'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Extract registry name
          $preRegistryName = "${{ parameters.preRegistry }}" -split '\.' | Select-Object -First 1
          
          # Login to Pre ACR
          az acr login --name $preRegistryName
          
          # Push to Pre ACR
          $preChartRef = "oci://${{ parameters.preRegistry }}/$(preChartRepository)"
          $chartPath = "$(repackagedChartPath)"
          Write-Host "Pushing Helm chart to: $preChartRef"
          Write-Host "Chart file: $chartPath"
          helm push $chartPath $preChartRef

- stage: PushHelmToPrivateRepo
  displayName: 'Push scanned Helm chart to Live ACR'
  dependsOn: PushHelmToPreACR
  condition: and(${{ parameters.enableHelmStages }}, succeeded())
  jobs:
  - job: PullTagAndPushHelm
    displayName: 'Pull, Tag, and Push Helm Chart'
    pool:
      name: Tiberius
      demands:
      - ENVIRONMENT -equals BUS
    variables:
      # Helm appends chart name from Chart.yaml, so use parent path only
      preChartRepository: 'scanned/testcharts/testchart'
      # Get versions from Pre stage output
      originalVersion: $[ stageDependencies.PushHelmToPreACR.PushHelmToPre.outputs['pullChart.helmChartVersion'] ]
      scannedVersion: $[ stageDependencies.PushHelmToPreACR.PushHelmToPre.outputs['pullChart.scannedChartVersion'] ]
    steps:
    - task: AzureCLI@2
      displayName: 'Pull and Repackage Scanned Chart from Pre ACR'
      inputs:
        azureSubscription: '${{ parameters.preAzureSubscription }}'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Get versions from stage variables
          $chartVersion = "$(originalVersion)"
          $scannedVersion = "$(scannedVersion)"
          
          Write-Host "Original version: $chartVersion"
          Write-Host "Scanned version from Pre: $scannedVersion"
          
          # Create temp directory
          $chartDir = New-Item -ItemType Directory -Path "$(Agent.TempDirectory)/helm-charts-final" -Force
          
          # Login to Pre ACR and pull scanned chart
          $preRegistryName = "${{ parameters.preRegistry }}" -split '\.' | Select-Object -First 1
          az acr login --name $preRegistryName
          
          $preChartRef = "oci://${{ parameters.preRegistry }}/$(preChartRepository)"
          Write-Host "Pulling scanned Helm chart from: $preChartRef --version $scannedVersion"
          helm pull $preChartRef --version $scannedVersion --destination $chartDir.FullName
          
          # Get the downloaded chart file
          $chartFile = Get-ChildItem -Path $chartDir.FullName -Filter "*.tgz" | Select-Object -First 1
          
          if (-not $chartFile) {
            Write-Host "##[error]Failed to pull chart from Pre ACR. The az acr login for Pre ACR likely failed because this task is authenticated to source subscription, not Pre subscription."
            Write-Host "##[error]Chart was not found in: $($chartDir.FullName)"
            exit 1
          }
          
          # Extract and modify chart version back to original
          $extractDir = New-Item -ItemType Directory -Path "$(Agent.TempDirectory)/helm-repackage-live" -Force
          tar -xzf $chartFile.FullName -C $extractDir.FullName
          
          $chartName = Get-ChildItem -Path $extractDir.FullName -Directory | Select-Object -First 1
          $chartYaml = Get-Content "$($chartName.FullName)/Chart.yaml" -Raw
          $chartYaml = $chartYaml -replace 'version:\s+.*', "version: $chartVersion"
          Set-Content "$($chartName.FullName)/Chart.yaml" -Value $chartYaml
          
          # Repackage with original version
          $packageOutput = helm package $chartName.FullName --destination $chartDir.FullName
          Write-Host $packageOutput
          
          # Extract the actual file path from helm package output
          if ($packageOutput -match ':\s+(.+\.tgz)$') {
            $repackagedChart = $matches[1]
          } else {
            # Fallback: find the .tgz file
            $repackagedChart = (Get-ChildItem -Path $chartDir.FullName -Filter "*-$chartVersion.tgz" | Select-Object -First 1).FullName
          }
          
          Write-Host "Repackaged chart path: $repackagedChart"
          Write-Host "##vso[task.setvariable variable=repackagedChartPath]$repackagedChart"

    - task: AzureCLI@2
      displayName: 'Push Helm Chart to Live ACR'
      inputs:
        azureSubscription: '${{ parameters.liveAzureSubscription }}'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Extract registry name
          $liveRegistryName = "${{ parameters.destinationRegistry }}" -split '\.' | Select-Object -First 1
          
          # Acquire an ACR access token that Helm can use
          $accessToken = az acr login --name $liveRegistryName --expose-token --output tsv --query accessToken
          if ([string]::IsNullOrWhiteSpace($accessToken)) {
            Write-Host "##[error]Failed to obtain access token for Live ACR"
            exit 1
          }

          # Login to Live ACR using Helm's registry auth (token is treated as password)
          $helmRegistry = "${{ parameters.destinationRegistry }}"
          Write-Host "Logging into Live ACR registry with Helm..."
          $accessToken | helm registry login $helmRegistry --username 00000000-0000-0000-0000-000000000000 --password-stdin

          # Push to Live ACR (use base path without chart name, Helm will append it)
          $liveChartRef = "oci://${{ parameters.destinationRegistry }}/testcharts"
          $chartPath = "$(repackagedChartPath)"
          Write-Host "Pushing Helm chart to: $liveChartRef"
          Write-Host "Chart file: $chartPath"
          helm push $chartPath $liveChartRef

- stage: AlertOnHelmSuccess
  displayName: 'Alert that Helm scan completed successfully'
  dependsOn: [PushHelmToPreACR, PushHelmToPrivateRepo]
  condition: and(${{ parameters.enableHelmStages }}, succeeded())
  jobs:
  - job: SendHelmSuccessTeamsMessage
    displayName: 'Send Helm Success Alert to Teams Channel'
    pool: Mare Nectaris
    steps:
    - task: PowerShell@2
      displayName: 'Send Teams Alert'
      inputs:
        targetType: 'inline'
        script: |
          $body = @{
            title = "Helm Chart Scan Completed Successfully"
            message = "Helm chart scanning passed and chart has been pushed to live and pre private registries."
            status = "success"
            sourceHost = "${{ parameters.sourceHost }}"
            sourceRepository = "${{ parameters.sourceRepository }}"
            destinationRegistry = "${{ parameters.destinationRegistry }}"
            preRegistry = "${{ parameters.preRegistry }}"
            pipelineUrl = "$(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
          } | ConvertTo-Json
          
          Invoke-RestMethod -Uri "${{ parameters.teamsWebhookEndpoint }}" -Method Post -Body $body -ContentType 'application/json'

- stage: AlertOnHelmFail
  displayName: 'Alert that vulnerable Helm chart present'
  dependsOn: ScanHelmChart
  condition: and(${{ parameters.enableHelmStages }}, failed())
  jobs:
  - job: PushPreVulnerableHelmChart
    displayName: 'Push Vulnerable Helm Chart to Pre vulnerable namespace'
    pool:
      name: Tiberius
      demands:
      - ENVIRONMENT -equals ENG
    variables:
      vulnerableChartRepository: 'vulnerable/${{ parameters.sourceRepository }}'
    steps:
    - task: AzureCLI@2
      displayName: 'Pull and Repackage Vulnerable Chart'
      inputs:
        azureSubscription: '${{ parameters.sourceAzureSubscription }}'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Extract registry name
          $sourceRegistryName = "${{ parameters.sourceHost }}" -split '\.' | Select-Object -First 1
          
          # Login to source ACR
          az acr login --name $sourceRegistryName
          
          # Get chart version
          $manifest = az acr manifest show --name ${{ parameters.sourceRepository }} --registry $sourceRegistryName --output json | ConvertFrom-Json
          $chartVersion = $manifest.config.annotations.'org.opencontainers.image.version'
          if ([string]::IsNullOrWhiteSpace($chartVersion)) {
            $chartVersion = "${{ parameters.sourceTag }}"
          }
          Write-Host "##vso[task.setvariable variable=helmChartVersion]$chartVersion"
          $vulnerableVersion = "$chartVersion-vulnerable"
          Write-Host "##vso[task.setvariable variable=vulnerableChartTag]$vulnerableVersion"
          
          # Create temp directory
          $chartDir = New-Item -ItemType Directory -Path "$(Agent.TempDirectory)/helm-charts-vulnerable" -Force
          
          # Pull the Helm chart
          $chartReference = "oci://${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}"
          Write-Host "Pulling vulnerable Helm chart: $chartReference --version $chartVersion"
          helm pull $chartReference --version $chartVersion --destination $chartDir.FullName
          
          # Get the downloaded chart file
          $chartFile = Get-ChildItem -Path $chartDir.FullName -Filter "*.tgz" | Select-Object -First 1
          
          # Extract and modify version for vulnerable tag
          $extractDir = New-Item -ItemType Directory -Path "$(Agent.TempDirectory)/helm-repackage-vuln" -Force
          tar -xzf $chartFile.FullName -C $extractDir.FullName
          
          $chartName = Get-ChildItem -Path $extractDir.FullName -Directory | Select-Object -First 1
          $chartYaml = Get-Content "$($chartName.FullName)/Chart.yaml" -Raw
          $chartYaml = $chartYaml -replace 'version:\s+.*', "version: $vulnerableVersion"
          Set-Content "$($chartName.FullName)/Chart.yaml" -Value $chartYaml
          
          # Repackage with vulnerable version
          $packageOutput = helm package $chartName.FullName --destination $chartDir.FullName
          Write-Host $packageOutput
          
          # Extract the actual file path from helm package output
          if ($packageOutput -match ':\s+(.+\.tgz)$') {
            $repackagedChart = $matches[1]
          } else {
            # Fallback: find the .tgz file
            $repackagedChart = (Get-ChildItem -Path $chartDir.FullName -Filter "*-$vulnerableVersion.tgz" | Select-Object -First 1).FullName
          }
          
          Write-Host "Repackaged chart path: $repackagedChart"
          Write-Host "##vso[task.setvariable variable=repackagedChartPath]$repackagedChart"

    - task: AzureCLI@2
      displayName: 'Push Vulnerable Chart to Pre ACR'
      inputs:
        azureSubscription: '${{ parameters.preAzureSubscription }}'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Extract registry name
          $preRegistryName = "${{ parameters.preRegistry }}" -split '\.' | Select-Object -First 1
          
          # Login to Pre ACR
          az acr login --name $preRegistryName
          
          # Push to vulnerable path in Pre ACR
          $vulnerableChartRef = "oci://${{ parameters.preRegistry }}/$(vulnerableChartRepository)"
          $chartPath = "$(repackagedChartPath)"
          Write-Host "Pushing vulnerable chart to: $vulnerableChartRef"
          Write-Host "Chart file: $chartPath"
          helm push $chartPath $vulnerableChartRef

  - job: SendHelmFailureTeamsMessage
    displayName: 'Send Helm Failure Alert to Teams Channel'
    dependsOn: PushPreVulnerableHelmChart
    condition: always()
    pool: Mare Nectaris
    steps:
    - task: PowerShell@2
      displayName: 'Send Teams Alert'
      inputs:
        targetType: 'inline'
        script: |
          $body = @{
            title = "Helm Chart Scan Failed"
            message = "Helm chart scanning failed due to vulnerabilities detected in chart: ${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}. Vulnerable chart pushed to pre registry."
            status = "failure"
            sourceHost = "${{ parameters.sourceHost }}"
            sourceRepository = "${{ parameters.sourceRepository }}"
            preRegistry = "${{ parameters.preRegistry }}"
            vulnerableRepository = "vulnerable/${{ parameters.sourceRepository }}"
            pipelineUrl = "$(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
          } | ConvertTo-Json
          
          Invoke-RestMethod -Uri "${{ parameters.teamsWebhookEndpoint }}" -Method Post -Body $body -ContentType 'application/json'

