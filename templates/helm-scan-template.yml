parameters:
  - name: sourceAzureSubscription
    type: string
  - name: preAzureSubscription
    type: string
  - name: liveAzureSubscription
    type: string
  - name: sourceRegistryServiceConnection
    type: string
  - name: destinationRegistryServiceConnection
    type: string
  - name: preRegistryServiceConnection
    type: string
  - name: destinationRegistry
    type: string
  - name: preRegistry
    type: string
  - name: snykServiceConnection
    type: string
  - name: snykOrganization
    type: string
  - name: teamsWebhookEndpoint
    type: string
  - name: sourceRepository
    type: string
  - name: sourceTag
    type: string
  - name: sourceHost
    type: string

stages:
- stage: ScanHelmChart
  displayName: 'Scan Helm Chart with Snyk IaC'
  condition: succeeded()
  jobs:
  - job: HelmChartScan
    displayName: 'Scan Pushed Helm Chart'
    pool:
      name: Tiberius
      demands:
      - ENVIRONMENT -equals BUS
    steps:
    - task: AzureCLI@2
      displayName: 'Login to ACR and Pull Helm Chart'
      inputs:
        azureSubscription: '${{ parameters.sourceAzureSubscription }}'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Extract registry info
          $registryHost = "${{ parameters.sourceHost }}"
          $registryName = $registryHost -split '\.' | Select-Object -First 1
          
          # Get the chart version from manifest (Helm charts don't have sourceTag in webhook)
          $manifest = az acr manifest show --name ${{ parameters.sourceRepository }} --registry $registryName --output json | ConvertFrom-Json
          $chartVersion = $manifest.config.annotations.'org.opencontainers.image.version'
          
          if ([string]::IsNullOrWhiteSpace($chartVersion)) {
            Write-Host "##[warning]Could not determine chart version from manifest, using sourceTag parameter"
            $chartVersion = "${{ parameters.sourceTag }}"
          }
          
          Write-Host "Helm chart version: $chartVersion"
          Write-Host "##vso[task.setvariable variable=helmChartVersion]$chartVersion"
          
          $accessToken = az acr login --name $registryName --expose-token --output tsv --query accessToken
          if ([string]::IsNullOrWhiteSpace($accessToken)) {
            Write-Host "##[error]Failed to obtain registry token for $registryHost"
            exit 1
          }
          
          # Create temp directory for chart
          $chartDir = New-Item -ItemType Directory -Path "$(Agent.TempDirectory)/helm-charts" -Force
          
          # Pull the Helm chart
          $chartReference = "oci://$registryHost/${{ parameters.sourceRepository }}"
          Write-Host "Pulling Helm chart: $chartReference --version $chartVersion"
          try {
            $accessToken | helm registry login $registryHost --username 00000000-0000-0000-0000-000000000000 --password-stdin
            helm pull $chartReference --version $chartVersion --destination $chartDir.FullName --untar
          } finally {
            helm registry logout $registryHost | Out-Null
          }
          
          # Set variable for extracted chart path
          $extractedChart = Get-ChildItem -Path $chartDir.FullName -Directory | Select-Object -First 1
          Write-Host "##vso[task.setvariable variable=helmChartPath]$($extractedChart.FullName)"
          Write-Host "Helm chart extracted to: $($extractedChart.FullName)"

    - task: UkhoSnykScanTask@0
      displayName: 'Snyk IaC scan for Helm Chart'
      inputs:
        failOnIssues: true
        organization: '${{ parameters.snykOrganization }}'
        serviceConnectionEndpoint: '${{ parameters.snykServiceConnection }}'
        testType: iac
        monitorWhen: always
        severityThreshold: high
        targetFile: '$(helmChartPath)'

- stage: PushHelmToPreACR
  displayName: 'Push scanned Helm chart to Pre ACR'
  dependsOn: ScanHelmChart
  condition: succeeded('ScanHelmChart')
  jobs:
  - job: PushHelmToPre
    displayName: 'Push Helm Chart to Pre ACR'
    pool:
      name: Tiberius
      demands:
      - ENVIRONMENT -equals ENG
    variables:
      scannedChartTag: '$(helmChartVersion)-snyk-scanned'
      # Helm appends chart name from Chart.yaml, so use parent path only
      preChartRepository: 'scanned/charts'
    steps:
    - task: AzureCLI@2
      displayName: 'Pull Helm Chart from Source ACR'
      inputs:
        azureSubscription: '${{ parameters.sourceAzureSubscription }}'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Extract registry name
          $sourceRegistryHost = "${{ parameters.sourceHost }}"
          $sourceRegistryName = $sourceRegistryHost -split '\.' | Select-Object -First 1
          
          $accessToken = az acr login --name $sourceRegistryName --expose-token --output tsv --query accessToken
          if ([string]::IsNullOrWhiteSpace($accessToken)) {
            Write-Host "##[error]Failed to obtain registry token for $sourceRegistryHost"
            exit 1
          }
          $chartDir = New-Item -ItemType Directory -Path "$(Agent.TempDirectory)/helm-charts-push" -Force
          
          # Pull the Helm chart (without version to get latest if no version)
          $chartReference = "oci://$sourceRegistryHost/${{ parameters.sourceRepository }}"
          Write-Host "Pulling Helm chart: $chartReference"
          try {
            $accessToken | helm registry login $sourceRegistryHost --username 00000000-0000-0000-0000-000000000000 --password-stdin
            helm pull $chartReference --destination $chartDir.FullName
          } finally {
            helm registry logout $sourceRegistryHost | Out-Null
          }
          $chartFile = Get-ChildItem -Path $chartDir.FullName -Filter "*.tgz" | Select-Object -First 1
          if (-not $chartFile) {
            Write-Host "##[error]Unable to locate pulled chart artifact"
            exit 1
          }
          
          # Extract to get version
          $extractDir = New-Item -ItemType Directory -Path "$(Agent.TempDirectory)/helm-repackage" -Force
          tar -xzf $chartFile.FullName -C $extractDir.FullName
          
          $chartName = Get-ChildItem -Path $extractDir.FullName -Directory | Select-Object -First 1
          if (-not $chartName) {
            Write-Host "##[error]Unable to identify chart directory after extraction"
            exit 1
          }
          $chartYaml = Get-Content "$($chartName.FullName)/Chart.yaml" -Raw
          $versionMatch = [regex]::Match($chartYaml, 'version:\s*(.+)')
          if (-not $versionMatch.Success) {
            Write-Host "##[error]Unable to detect chart version"
            exit 1
          }
          $chartVersion = $versionMatch.Groups[1].Value.Trim()
          Write-Host "Using chart version: $chartVersion"
          Write-Host "##vso[task.setvariable variable=helmChartVersion;isOutput=true]$chartVersion"
          
          $newVersion = "$chartVersion-snyk-scanned"
          Write-Host "##vso[task.setvariable variable=scannedChartVersion;isOutput=true]$newVersion"
          $chartYaml = $chartYaml -replace 'version:\s+.*', "version: $newVersion"
          Set-Content "$($chartName.FullName)/Chart.yaml" -Value $chartYaml
          
          # Repackage with new version
          $packageOutput = helm package $chartName.FullName --destination $chartDir.FullName
          Write-Host $packageOutput
          
          # Extract the actual file path from helm package output
          if ($packageOutput -match ':\s+(.+\.tgz)$') {
            $repackagedChart = $matches[1]
          } else {
            # Fallback: find the .tgz file
            $repackagedChart = (Get-ChildItem -Path $chartDir.FullName -Filter "*-$newVersion.tgz" | Select-Object -First 1).FullName
          }
          
          if (-not $repackagedChart) {
            Write-Host "##[error]Unable to locate repackaged chart"
            exit 1
          }
          Write-Host "Repackaged chart path: $repackagedChart"
          Write-Host "##vso[task.setvariable variable=repackagedChartPath]$repackagedChart"
      name: pullChart

    - task: AzureCLI@2
      displayName: 'Push Helm Chart to Pre ACR'
      inputs:
        azureSubscription: '${{ parameters.preAzureSubscription }}'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Extract registry name
          $preRegistryHost = "${{ parameters.preRegistry }}"
          $preRegistryName = $preRegistryHost -split '\.' | Select-Object -First 1
          
          $accessToken = az acr login --name $preRegistryName --expose-token --output tsv --query accessToken
          if ([string]::IsNullOrWhiteSpace($accessToken)) {
            Write-Host "##[error]Failed to obtain registry token for $preRegistryHost"
            exit 1
          }
          
          # Push to Pre ACR
          $preChartRef = "oci://$preRegistryHost/$(preChartRepository)"
          $chartPath = "$(repackagedChartPath)"
          Write-Host "Pushing Helm chart to: $preChartRef"
          Write-Host "Chart file: $chartPath"
          try {
            $accessToken | helm registry login $preRegistryHost --username 00000000-0000-0000-0000-000000000000 --password-stdin
            helm push $chartPath $preChartRef
          } finally {
            helm registry logout $preRegistryHost | Out-Null
          }

- stage: PushHelmToPrivateRepo
  displayName: 'Push scanned Helm chart to Live ACR'
  dependsOn: PushHelmToPreACR
  condition: succeeded('PushHelmToPreACR')
  jobs:
  - job: PullTagAndPushHelm
    displayName: 'Pull, Tag, and Push Helm Chart'
    pool:
      name: Tiberius
      demands:
      - ENVIRONMENT -equals BUS
    variables:
      # Helm appends chart name from Chart.yaml, so use parent path only
      preChartRepository: 'scanned/charts'
    steps:
    - task: AzureCLI@2
      displayName: 'Pull and Repackage Scanned Chart from Pre ACR'
      inputs:
        azureSubscription: '${{ parameters.preAzureSubscription }}'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Create temp directory
          $chartName = "${{ parameters.sourceRepository }}" -split '/' | Select-Object -Last 1
          $preChartRepository = "scanned/charts/$chartName"
          $chartDir = New-Item -ItemType Directory -Path "$(Agent.TempDirectory)/helm-charts-final" -Force
          
          # Login to Pre ACR and pull scanned chart
          $preRegistryHost = "${{ parameters.preRegistry }}"
          $preRegistryName = $preRegistryHost -split '\.' | Select-Object -First 1
          $accessToken = az acr login --name $preRegistryName --expose-token --output tsv --query accessToken
          if ([string]::IsNullOrWhiteSpace($accessToken)) {
            Write-Host "##[error]Failed to obtain registry token for $preRegistryHost"
            exit 1
          }
          
          # Get the latest tag for the chart
          $tags = az acr repository show-tags --name $preRegistryName --repository $preChartRepository --output json | ConvertFrom-Json
          $latestTag = ($tags | Sort-Object -Descending | Select-Object -First 1)
          
          Write-Host "Latest tag for chart: $latestTag"
          
          $preChartRef = "oci://$preRegistryHost/$preChartRepository"
          Write-Host "Pulling scanned Helm chart from: $preChartRef --version $latestTag"
          try {
            $accessToken | helm registry login $preRegistryHost --username 00000000-0000-0000-0000-000000000000 --password-stdin
            helm pull $preChartRef --version $latestTag --destination $chartDir.FullName
          } finally {
            helm registry logout $preRegistryHost | Out-Null
          }
          
          # Get the downloaded chart file
          $chartFile = Get-ChildItem -Path $chartDir.FullName -Filter "*.tgz" | Select-Object -First 1
          
          if (-not $chartFile) {
            Write-Host "##[error]Failed to pull chart from Pre ACR."
            exit 1
          }
          
          # Extract to get version
          $extractDir = New-Item -ItemType Directory -Path "$(Agent.TempDirectory)/helm-repackage-live" -Force
          tar -xzf $chartFile.FullName -C $extractDir.FullName
          
          $chartName = Get-ChildItem -Path $extractDir.FullName -Directory | Select-Object -First 1
          $chartYaml = Get-Content "$($chartName.FullName)/Chart.yaml" -Raw
          $versionMatch = [regex]::Match($chartYaml, 'version:\s*(.+)')
          $scannedVersion = $versionMatch.Groups[1].Value.Trim()
          $originalVersion = $scannedVersion -replace '-snyk-scanned', ''
          
          Write-Host "Parsed scanned version: $scannedVersion"
          Write-Host "Parsed original version: $originalVersion"
          
          # Modify chart version back to original
          $chartYaml = $chartYaml -replace 'version:\s+.*', "version: $originalVersion"
          Set-Content "$($chartName.FullName)/Chart.yaml" -Value $chartYaml
          
          # Repackage with original version
          $packageOutput = helm package $chartName.FullName --destination $chartDir.FullName
          Write-Host $packageOutput
          
          # Extract the actual file path from helm package output
          if ($packageOutput -match ':\s+(.+\.tgz)$') {
            $repackagedChart = $matches[1]
          } else {
            # Fallback: find the .tgz file
            $repackagedChart = (Get-ChildItem -Path $chartDir.FullName -Filter "*-$originalVersion.tgz" | Select-Object -First 1).FullName
          }
          
          Write-Host "Repackaged chart path: $repackagedChart"
          Write-Host "##vso[task.setvariable variable=repackagedChartPath]$repackagedChart"

    - task: AzureCLI@2
      displayName: 'Push Helm Chart to Live ACR'
      inputs:
        azureSubscription: '${{ parameters.liveAzureSubscription }}'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Extract registry name
          $liveRegistryHost = "${{ parameters.destinationRegistry }}"
          $liveRegistryName = $liveRegistryHost -split '\.' | Select-Object -First 1
          
          # Acquire an ACR access token that Helm can use
          $accessToken = az acr login --name $liveRegistryName --expose-token --output tsv --query accessToken
          if ([string]::IsNullOrWhiteSpace($accessToken)) {
            Write-Host "##[error]Failed to obtain access token for Live ACR"
            exit 1
          }

          # Login to Live ACR using Helm's registry auth (token is treated as password)
          $helmRegistry = $liveRegistryHost
          $liveChartRef = "oci://$liveRegistryHost/scanned/charts"
          $chartPath = "$(repackagedChartPath)"
          Write-Host "Pushing Helm chart to: $liveChartRef"
          Write-Host "Chart file: $chartPath"
          try {
            Write-Host "Logging into Live ACR registry with Helm..."
            $accessToken | helm registry login $helmRegistry --username 00000000-0000-0000-0000-000000000000 --password-stdin
            helm push $chartPath $liveChartRef
          } finally {
            helm registry logout $helmRegistry | Out-Null
          }

- stage: AlertOnHelmSuccess
  displayName: 'Alert that Helm scan completed successfully'
  dependsOn: [PushHelmToPreACR, PushHelmToPrivateRepo]
  condition: and(succeeded('PushHelmToPreACR'), succeeded('PushHelmToPrivateRepo'))
  jobs:
  - job: SendHelmSuccessTeamsMessage
    displayName: 'Send Helm Success Alert to Teams Channel'
    pool: Mare Nectaris
    steps:
    - task: PowerShell@2
      displayName: 'Send Teams Alert'
      inputs:
        targetType: 'inline'
        script: |
          $body = @{
            title = "Helm Chart Scan Completed Successfully"
            message = "Helm chart scanning passed and chart has been pushed to live and pre private registries."
            status = "success"
            sourceHost = "${{ parameters.sourceHost }}"
            sourceRepository = "${{ parameters.sourceRepository }}"
            destinationRegistry = "${{ parameters.destinationRegistry }}"
            preRegistry = "${{ parameters.preRegistry }}"
            pipelineUrl = "$(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
          } | ConvertTo-Json
          
          Invoke-RestMethod -Uri "${{ parameters.teamsWebhookEndpoint }}" -Method Post -Body $body -ContentType 'application/json'

- stage: AlertOnHelmFail
  displayName: 'Alert that vulnerable Helm chart present'
  dependsOn: ScanHelmChart
  condition: failed('ScanHelmChart')
  jobs:
  - job: PushPreVulnerableHelmChart
    displayName: 'Push Vulnerable Helm Chart to Pre vulnerable namespace'
    pool:
      name: Tiberius
      demands:
      - ENVIRONMENT -equals ENG
    variables:
      vulnerableChartRepository: 'vulnerable/${{ parameters.sourceRepository }}'
    steps:
    - task: AzureCLI@2
      displayName: 'Pull and Repackage Vulnerable Chart'
      inputs:
        azureSubscription: '${{ parameters.sourceAzureSubscription }}'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Extract registry name
          $sourceRegistryHost = "${{ parameters.sourceHost }}"
          $sourceRegistryName = $sourceRegistryHost -split '\.' | Select-Object -First 1
          
          $accessToken = az acr login --name $sourceRegistryName --expose-token --output tsv --query accessToken
          if ([string]::IsNullOrWhiteSpace($accessToken)) {
            Write-Host "##[error]Failed to obtain registry token for $sourceRegistryHost"
            exit 1
          }
          
          # Get chart version
          $manifest = az acr manifest show --name ${{ parameters.sourceRepository }} --registry $sourceRegistryName --output json | ConvertFrom-Json
          $chartVersion = $manifest.config.annotations.'org.opencontainers.image.version'
          if ([string]::IsNullOrWhiteSpace($chartVersion)) {
            $chartVersion = "${{ parameters.sourceTag }}"
          }
          Write-Host "##vso[task.setvariable variable=helmChartVersion]$chartVersion"
          $vulnerableVersion = "$chartVersion-vulnerable"
          Write-Host "##vso[task.setvariable variable=vulnerableChartTag]$vulnerableVersion"
          
          # Create temp directory
          $chartDir = New-Item -ItemType Directory -Path "$(Agent.TempDirectory)/helm-charts-vulnerable" -Force
          
          # Pull the Helm chart
          $chartReference = "oci://$sourceRegistryHost/${{ parameters.sourceRepository }}"
          Write-Host "Pulling vulnerable Helm chart: $chartReference --version $chartVersion"
          try {
            $accessToken | helm registry login $sourceRegistryHost --username 00000000-0000-0000-0000-000000000000 --password-stdin
            helm pull $chartReference --version $chartVersion --destination $chartDir.FullName
          } finally {
            helm registry logout $sourceRegistryHost | Out-Null
          }
          
          # Get the downloaded chart file
          $chartFile = Get-ChildItem -Path $chartDir.FullName -Filter "*.tgz" | Select-Object -First 1
          
          # Extract and modify version for vulnerable tag
          $extractDir = New-Item -ItemType Directory -Path "$(Agent.TempDirectory)/helm-repackage-vuln" -Force
          tar -xzf $chartFile.FullName -C $extractDir.FullName
          
          $chartName = Get-ChildItem -Path $extractDir.FullName -Directory | Select-Object -First 1
          $chartYaml = Get-Content "$($chartName.FullName)/Chart.yaml" -Raw
          $chartYaml = $chartYaml -replace 'version:\s+.*', "version: $vulnerableVersion"
          Set-Content "$($chartName.FullName)/Chart.yaml" -Value $chartYaml
          
          # Repackage with vulnerable version
          $packageOutput = helm package $chartName.FullName --destination $chartDir.FullName
          Write-Host $packageOutput
          
          # Extract the actual file path from helm package output
          if ($packageOutput -match ':\s+(.+\.tgz)$') {
            $repackagedChart = $matches[1]
          } else {
            # Fallback: find the .tgz file
            $repackagedChart = (Get-ChildItem -Path $chartDir.FullName -Filter "*-$vulnerableVersion.tgz" | Select-Object -First 1).FullName
          }
          
          Write-Host "Repackaged chart path: $repackagedChart"
          Write-Host "##vso[task.setvariable variable=repackagedChartPath]$repackagedChart"

    - task: AzureCLI@2
      displayName: 'Push Vulnerable Chart to Pre ACR'
      inputs:
        azureSubscription: '${{ parameters.preAzureSubscription }}'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Extract registry name
          $preRegistryHost = "${{ parameters.preRegistry }}"
          $preRegistryName = $preRegistryHost -split '\.' | Select-Object -First 1
          
          $accessToken = az acr login --name $preRegistryName --expose-token --output tsv --query accessToken
          if ([string]::IsNullOrWhiteSpace($accessToken)) {
            Write-Host "##[error]Failed to obtain registry token for $preRegistryHost"
            exit 1
          }
          
          # Push to vulnerable path in Pre ACR
          $vulnerableChartRef = "oci://$preRegistryHost/$(vulnerableChartRepository)"
          $chartPath = "$(repackagedChartPath)"
          Write-Host "Pushing vulnerable chart to: $vulnerableChartRef"
          Write-Host "Chart file: $chartPath"
          try {
            $accessToken | helm registry login $preRegistryHost --username 00000000-0000-0000-0000-000000000000 --password-stdin
            helm push $chartPath $vulnerableChartRef
          } finally {
            helm registry logout $preRegistryHost | Out-Null
          }

  - job: SendHelmFailureTeamsMessage
    displayName: 'Send Helm Failure Alert to Teams Channel'
    dependsOn: PushPreVulnerableHelmChart
    condition: always()
    pool: Mare Nectaris
    steps:
    - task: PowerShell@2
      displayName: 'Send Teams Alert'
      inputs:
        targetType: 'inline'
        script: |
          $body = @{
            title = "Helm Chart Scan Failed"
            message = "Helm chart scanning failed due to vulnerabilities detected in chart: ${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}. Vulnerable chart pushed to pre registry."
            status = "failure"
            sourceHost = "${{ parameters.sourceHost }}"
            sourceRepository = "${{ parameters.sourceRepository }}"
            preRegistry = "${{ parameters.preRegistry }}"
            vulnerableRepository = "vulnerable/${{ parameters.sourceRepository }}"
            pipelineUrl = "$(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
          } | ConvertTo-Json
          
          Invoke-RestMethod -Uri "${{ parameters.teamsWebhookEndpoint }}" -Method Post -Body $body -ContentType 'application/json'
