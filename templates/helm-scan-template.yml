parameters:
  - name: sourceAzureSubscription
    type: string
  - name: preAzureSubscription
    type: string
  - name: liveAzureSubscription
    type: string
  - name: sourceRegistryServiceConnection
    type: string
  - name: destinationRegistryServiceConnection
    type: string
  - name: preRegistryServiceConnection
    type: string
  - name: destinationRegistry
    type: string
  - name: preRegistry
    type: string
  - name: snykServiceConnection
    type: string
  - name: snykOrganization
    type: string
  - name: teamsWebhookEndpoint
    type: string
  - name: sourceRepository
    type: string
  - name: sourceTag
    type: string
  - name: sourceHost
    type: string

stages:
- stage: ScanHelmChart
  displayName: 'Scan Helm Chart with Snyk IaC'
  condition: succeeded()
  jobs:
  - job: HelmChartScan
    displayName: 'Scan Pushed Helm Chart'
    pool:
      name: Tiberius
      demands:
      - ENVIRONMENT -equals BUS
    steps:
    - task: AzureCLI@2
      displayName: 'Login to ACR and Pull Helm Chart'
      inputs:
        azureSubscription: '${{ parameters.sourceAzureSubscription }}'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          . "$(Build.SourcesDirectory)/scripts/import-helm-helpers.ps1"
          . "$(Build.SourcesDirectory)/scripts/import-helm-version-helpers.ps1"

          # Extract registry info
          $registryHost = "${{ parameters.sourceHost }}"
          $registryName = $registryHost -split '\.' | Select-Object -First 1
          
          # Get the chart version from manifest (Helm charts don't have sourceTag in webhook)
          $chartVersion = Get-HelmChartVersionFromManifest -RegistryName $registryName -Repository "${{ parameters.sourceRepository }}" -FallbackTag "${{ parameters.sourceTag }}"
          
          Write-Host "Helm chart version: $chartVersion"
          Write-Host "##vso[task.setvariable variable=helmChartVersion]$chartVersion"
          
          $accessToken = Get-AcrAccessToken -RegistryName $registryName -RegistryHost $registryHost
          
          # Create temp directory for chart
          $chartDir = New-Item -ItemType Directory -Path "$(Agent.TempDirectory)/helm-charts" -Force
          
          # Pull the Helm chart
          $chartReference = "oci://$registryHost/${{ parameters.sourceRepository }}"
          Write-Host "Pulling Helm chart: $chartReference --version $chartVersion"
          Invoke-HelmRegistryPull -RegistryHost $registryHost -AccessToken $accessToken -ChartReference $chartReference -Destination $chartDir.FullName -Version $chartVersion -Untar
          
          # Set variable for extracted chart path
          $extractedChart = Get-ChildItem -Path $chartDir.FullName -Directory | Select-Object -First 1
          Write-Host "##vso[task.setvariable variable=helmChartPath]$($extractedChart.FullName)"
          Write-Host "Helm chart extracted to: $($extractedChart.FullName)"

    - task: UkhoSnykScanTask@0
      displayName: 'Snyk IaC scan for Helm Chart'
      inputs:
        failOnIssues: true
        organization: '${{ parameters.snykOrganization }}'
        serviceConnectionEndpoint: '${{ parameters.snykServiceConnection }}'
        testType: iac
        monitorWhen: always
        severityThreshold: high
        targetFile: '$(helmChartPath)'

- stage: PushHelmToPreACR
  displayName: 'Push scanned Helm chart to Pre ACR'
  dependsOn: ScanHelmChart
  condition: succeeded('ScanHelmChart')
  jobs:
  - job: PushHelmToPre
    displayName: 'Push Helm Chart to Pre ACR'
    pool:
      name: Tiberius
      demands:
      - ENVIRONMENT -equals ENG
    variables:
      scannedChartTag: '$(helmChartVersion)-snyk-scanned'
      # Helm appends chart name from Chart.yaml, so use parent path only
      preChartRepository: 'scanned/charts'
    steps:
    - task: AzureCLI@2
      displayName: 'Pull Helm Chart from Source ACR'
      inputs:
        azureSubscription: '${{ parameters.sourceAzureSubscription }}'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          . "$(Build.SourcesDirectory)/scripts/import-helm-helpers.ps1"
          . "$(Build.SourcesDirectory)/scripts/import-helm-package.ps1"
          . "$(Build.SourcesDirectory)/scripts/import-helm-chart-helpers.ps1"
          . "$(Build.SourcesDirectory)/scripts/import-helm-artifact-helpers.ps1"

          # Extract registry name
          $sourceRegistryHost = "${{ parameters.sourceHost }}"
          $sourceRegistryName = $sourceRegistryHost -split '\.' | Select-Object -First 1
          
          $accessToken = Get-AcrAccessToken -RegistryName $sourceRegistryName -RegistryHost $sourceRegistryHost
          $chartDir = New-Item -ItemType Directory -Path "$(Agent.TempDirectory)/helm-charts-push" -Force
          
          # Pull the Helm chart (without version to get latest if no version)
          $chartReference = "oci://$sourceRegistryHost/${{ parameters.sourceRepository }}"
          Write-Host "Pulling Helm chart: $chartReference"
          Invoke-HelmRegistryPull -RegistryHost $sourceRegistryHost -AccessToken $accessToken -ChartReference $chartReference -Destination $chartDir.FullName
          $chartFile = Get-HelmChartArchivePath -SearchDirectory $chartDir.FullName -ErrorMessage "Unable to locate pulled chart artifact"
          
          # Extract to get version
          $chartPath = Expand-HelmChartArchive -ChartArchivePath $chartFile -Destination "$(Agent.TempDirectory)/helm-repackage"
          $chartVersion = Get-HelmChartVersion -ChartDirectory $chartPath
          Write-Host "Using chart version: $chartVersion"
          Write-Host "##vso[task.setvariable variable=helmChartVersion;isOutput=true]$chartVersion"
          
          $newVersion = "$chartVersion-snyk-scanned"
          Write-Host "##vso[task.setvariable variable=scannedChartVersion;isOutput=true]$newVersion"
          Set-HelmChartVersion -ChartDirectory $chartPath -Version $newVersion
          
          # Repackage with new version
          $repackagedChart = Invoke-HelmPackage -ChartDirectory $chartPath -Version $newVersion -Destination $chartDir.FullName
          
          if (-not $repackagedChart) {
            Write-Host "##[error]Unable to locate repackaged chart"
            exit 1
          }
          Write-Host "Repackaged chart path: $repackagedChart"
          Write-Host "##vso[task.setvariable variable=repackagedChartPath]$repackagedChart"
      name: pullChart

    - task: AzureCLI@2
      displayName: 'Push Helm Chart to Pre ACR'
      inputs:
        azureSubscription: '${{ parameters.preAzureSubscription }}'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          . "$(Build.SourcesDirectory)/scripts/import-helm-helpers.ps1"

          # Extract registry name
          $preRegistryHost = "${{ parameters.preRegistry }}"
          $preRegistryName = $preRegistryHost -split '\.' | Select-Object -First 1
          
          $accessToken = Get-AcrAccessToken -RegistryName $preRegistryName -RegistryHost $preRegistryHost
          
          # Push to Pre ACR
          $preChartRef = "oci://$preRegistryHost/$(preChartRepository)"
          $chartPath = "$(repackagedChartPath)"
          Write-Host "Pushing Helm chart to: $preChartRef"
          Write-Host "Chart file: $chartPath"
          Invoke-HelmRegistryPush -RegistryHost $preRegistryHost -AccessToken $accessToken -ChartPath $chartPath -ChartReference $preChartRef

- stage: PushHelmToPrivateRepo
  displayName: 'Push scanned Helm chart to Live ACR'
  dependsOn: PushHelmToPreACR
  condition: succeeded('PushHelmToPreACR')
  jobs:
  - job: PullTagAndPushHelm
    displayName: 'Pull, Tag, and Push Helm Chart'
    pool:
      name: Tiberius
      demands:
      - ENVIRONMENT -equals BUS
    variables:
      # Helm appends chart name from Chart.yaml, so use parent path only
      preChartRepository: 'scanned/charts'
    steps:
    - task: AzureCLI@2
      displayName: 'Pull and Repackage Scanned Chart from Pre ACR'
      inputs:
        azureSubscription: '${{ parameters.preAzureSubscription }}'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          . "$(Build.SourcesDirectory)/scripts/import-helm-helpers.ps1"
          . "$(Build.SourcesDirectory)/scripts/import-helm-package.ps1"
          . "$(Build.SourcesDirectory)/scripts/import-helm-chart-helpers.ps1"
          . "$(Build.SourcesDirectory)/scripts/import-helm-artifact-helpers.ps1"

          # Create temp directory
          $chartName = "${{ parameters.sourceRepository }}" -split '/' | Select-Object -Last 1
          $preChartRepository = "scanned/charts/$chartName"
          $chartDir = New-Item -ItemType Directory -Path "$(Agent.TempDirectory)/helm-charts-final" -Force
          
          # Login to Pre ACR and pull scanned chart
          $preRegistryHost = "${{ parameters.preRegistry }}"
          $preRegistryName = $preRegistryHost -split '\.' | Select-Object -First 1
          $accessToken = Get-AcrAccessToken -RegistryName $preRegistryName -RegistryHost $preRegistryHost
          
          # Get the latest tag for the chart
          $tags = az acr repository show-tags --name $preRegistryName --repository $preChartRepository --output json | ConvertFrom-Json
          $latestTag = ($tags | Sort-Object -Descending | Select-Object -First 1)
          
          Write-Host "Latest tag for chart: $latestTag"
          
          $preChartRef = "oci://$preRegistryHost/$preChartRepository"
          Write-Host "Pulling scanned Helm chart from: $preChartRef --version $latestTag"
          Invoke-HelmRegistryPull -RegistryHost $preRegistryHost -AccessToken $accessToken -ChartReference $preChartRef -Destination $chartDir.FullName -Version $latestTag
          
          # Get the downloaded chart file
          $chartFile = Get-HelmChartArchivePath -SearchDirectory $chartDir.FullName -ErrorMessage "Failed to pull chart from Pre ACR."
          
          # Extract to get version
          $chartPath = Expand-HelmChartArchive -ChartArchivePath $chartFile -Destination "$(Agent.TempDirectory)/helm-repackage-live"
          $scannedVersion = Get-HelmChartVersion -ChartDirectory $chartPath
          $originalVersion = $scannedVersion -replace '-snyk-scanned', ''
          
          Write-Host "Parsed scanned version: $scannedVersion"
          Write-Host "Parsed original version: $originalVersion"
          
          # Modify chart version back to original
          Set-HelmChartVersion -ChartDirectory $chartPath -Version $originalVersion
          
          # Repackage with original version
          $repackagedChart = Invoke-HelmPackage -ChartDirectory $chartPath -Version $originalVersion -Destination $chartDir.FullName
          
          Write-Host "Repackaged chart path: $repackagedChart"
          Write-Host "##vso[task.setvariable variable=repackagedChartPath]$repackagedChart"

    - task: AzureCLI@2
      displayName: 'Push Helm Chart to Live ACR'
      inputs:
        azureSubscription: '${{ parameters.liveAzureSubscription }}'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          . "$(Build.SourcesDirectory)/scripts/import-helm-helpers.ps1"

          # Extract registry name
          $liveRegistryHost = "${{ parameters.destinationRegistry }}"
          $liveRegistryName = $liveRegistryHost -split '\.' | Select-Object -First 1
          
          # Acquire an ACR access token that Helm can use
          $accessToken = Get-AcrAccessToken -RegistryName $liveRegistryName -RegistryHost $liveRegistryHost

          # Login to Live ACR using Helm's registry auth (token is treated as password)
          $liveChartRef = "oci://$liveRegistryHost/scanned/charts"
          $chartPath = "$(repackagedChartPath)"
          Write-Host "Pushing Helm chart to: $liveChartRef"
          Write-Host "Chart file: $chartPath"
          Invoke-HelmRegistryPush -RegistryHost $liveRegistryHost -AccessToken $accessToken -ChartPath $chartPath -ChartReference $liveChartRef

- stage: AlertOnHelmSuccess
  displayName: 'Alert that Helm scan completed successfully'
  dependsOn: [PushHelmToPreACR, PushHelmToPrivateRepo]
  condition: and(succeeded('PushHelmToPreACR'), succeeded('PushHelmToPrivateRepo'))
  jobs:
  - job: SendHelmSuccessTeamsMessage
    displayName: 'Send Helm Success Alert to Teams Channel'
    pool: Mare Nectaris
    steps:
    - task: PowerShell@2
      displayName: 'Send Teams Alert'
      inputs:
        targetType: 'inline'
        script: |
          $body = @{
            title = "Helm Chart Scan Completed Successfully"
            message = "Helm chart scanning passed and chart has been pushed to live and pre private registries."
            status = "success"
            sourceHost = "${{ parameters.sourceHost }}"
            sourceRepository = "${{ parameters.sourceRepository }}"
            destinationRegistry = "${{ parameters.destinationRegistry }}"
            preRegistry = "${{ parameters.preRegistry }}"
            pipelineUrl = "$(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
          } | ConvertTo-Json
          
          Invoke-RestMethod -Uri "${{ parameters.teamsWebhookEndpoint }}" -Method Post -Body $body -ContentType 'application/json'

- stage: AlertOnHelmFail
  displayName: 'Alert that vulnerable Helm chart present'
  dependsOn: ScanHelmChart
  condition: failed('ScanHelmChart')
  jobs:
  - job: PushPreVulnerableHelmChart
    displayName: 'Push Vulnerable Helm Chart to Pre vulnerable namespace'
    pool:
      name: Tiberius
      demands:
      - ENVIRONMENT -equals ENG
    variables:
      vulnerableChartRepository: 'vulnerable/${{ parameters.sourceRepository }}'
    steps:
    - task: AzureCLI@2
      displayName: 'Pull and Repackage Vulnerable Chart'
      inputs:
        azureSubscription: '${{ parameters.sourceAzureSubscription }}'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          . "$(Build.SourcesDirectory)/scripts/import-helm-helpers.ps1"
          . "$(Build.SourcesDirectory)/scripts/import-helm-package.ps1"
          . "$(Build.SourcesDirectory)/scripts/import-helm-chart-helpers.ps1"
          . "$(Build.SourcesDirectory)/scripts/import-helm-artifact-helpers.ps1"
          . "$(Build.SourcesDirectory)/scripts/import-helm-version-helpers.ps1"

          # Extract registry name
          $sourceRegistryHost = "${{ parameters.sourceHost }}"
          $sourceRegistryName = $sourceRegistryHost -split '\.' | Select-Object -First 1
          
          $accessToken = Get-AcrAccessToken -RegistryName $sourceRegistryName -RegistryHost $sourceRegistryHost
          
          # Get chart version
          $chartVersion = Get-HelmChartVersionFromManifest -RegistryName $sourceRegistryName -Repository "${{ parameters.sourceRepository }}" -FallbackTag "${{ parameters.sourceTag }}"
          Write-Host "##vso[task.setvariable variable=helmChartVersion]$chartVersion"
          $vulnerableVersion = "$chartVersion-vulnerable"
          Write-Host "##vso[task.setvariable variable=vulnerableChartTag]$vulnerableVersion"
          
          # Create temp directory
          $chartDir = New-Item -ItemType Directory -Path "$(Agent.TempDirectory)/helm-charts-vulnerable" -Force
          
          # Pull the Helm chart
          $chartReference = "oci://$sourceRegistryHost/${{ parameters.sourceRepository }}"
          Write-Host "Pulling vulnerable Helm chart: $chartReference --version $chartVersion"
          Invoke-HelmRegistryPull -RegistryHost $sourceRegistryHost -AccessToken $accessToken -ChartReference $chartReference -Destination $chartDir.FullName -Version $chartVersion
          
          # Get the downloaded chart file
          $chartFile = Get-HelmChartArchivePath -SearchDirectory $chartDir.FullName -ErrorMessage "Unable to locate vulnerable chart artifact"
          
          # Extract and modify version for vulnerable tag
          $chartPath = Expand-HelmChartArchive -ChartArchivePath $chartFile -Destination "$(Agent.TempDirectory)/helm-repackage-vuln"
          Set-HelmChartVersion -ChartDirectory $chartPath -Version $vulnerableVersion
          
          # Repackage with vulnerable version
          $repackagedChart = Invoke-HelmPackage -ChartDirectory $chartPath -Version $vulnerableVersion -Destination $chartDir.FullName
          
          Write-Host "Repackaged chart path: $repackagedChart"
          Write-Host "##vso[task.setvariable variable=repackagedChartPath]$repackagedChart"

    - task: AzureCLI@2
      displayName: 'Push Vulnerable Chart to Pre ACR'
      inputs:
        azureSubscription: '${{ parameters.preAzureSubscription }}'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          . "$(Build.SourcesDirectory)/scripts/import-helm-helpers.ps1"

          # Extract registry name
          $preRegistryHost = "${{ parameters.preRegistry }}"
          $preRegistryName = $preRegistryHost -split '\.' | Select-Object -First 1
          
          $accessToken = Get-AcrAccessToken -RegistryName $preRegistryName -RegistryHost $preRegistryHost
          
          # Push to vulnerable path in Pre ACR
          $vulnerableChartRef = "oci://$preRegistryHost/$(vulnerableChartRepository)"
          $chartPath = "$(repackagedChartPath)"
          Write-Host "Pushing vulnerable chart to: $vulnerableChartRef"
          Write-Host "Chart file: $chartPath"
          Invoke-HelmRegistryPush -RegistryHost $preRegistryHost -AccessToken $accessToken -ChartPath $chartPath -ChartReference $vulnerableChartRef

  - job: SendHelmFailureTeamsMessage
    displayName: 'Send Helm Failure Alert to Teams Channel'
    dependsOn: PushPreVulnerableHelmChart
    condition: always()
    pool: Mare Nectaris
    steps:
    - task: PowerShell@2
      displayName: 'Send Teams Alert'
      inputs:
        targetType: 'inline'
        script: |
          $body = @{
            title = "Helm Chart Scan Failed"
            message = "Helm chart scanning failed due to vulnerabilities detected in chart: ${{ parameters.sourceHost }}/${{ parameters.sourceRepository }}. Vulnerable chart pushed to pre registry."
            status = "failure"
            sourceHost = "${{ parameters.sourceHost }}"
            sourceRepository = "${{ parameters.sourceRepository }}"
            preRegistry = "${{ parameters.preRegistry }}"
            vulnerableRepository = "vulnerable/${{ parameters.sourceRepository }}"
            pipelineUrl = "$(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
          } | ConvertTo-Json
          
          Invoke-RestMethod -Uri "${{ parameters.teamsWebhookEndpoint }}" -Method Post -Body $body -ContentType 'application/json'
